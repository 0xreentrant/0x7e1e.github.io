import { basename, parse, resolve, sep, extname, join, dirname } from 'path';
import { readdir, stat, readFile, mkdir, writeFile, copyFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { EOL } from 'os';
import { marked } from 'marked';

var PRPLSourceFileExtension;
(function (PRPLSourceFileExtension) {
    PRPLSourceFileExtension["html"] = ".html";
})(PRPLSourceFileExtension || (PRPLSourceFileExtension = {}));
var PRPLContentFileExtension;
(function (PRPLContentFileExtension) {
    PRPLContentFileExtension["html"] = ".html";
    PRPLContentFileExtension["markdown"] = ".md";
})(PRPLContentFileExtension || (PRPLContentFileExtension = {}));
var PRPLTag;
(function (PRPLTag) {
    PRPLTag["page"] = "page";
    PRPLTag["list"] = "list";
})(PRPLTag || (PRPLTag = {}));
var PRPLTagAttribute;
(function (PRPLTagAttribute) {
    PRPLTagAttribute["type"] = "type";
    PRPLTagAttribute["src"] = "src";
    PRPLTagAttribute["sortBy"] = "sort-by";
    PRPLTagAttribute["direction"] = "direction";
    PRPLTagAttribute["limit"] = "limit";
})(PRPLTagAttribute || (PRPLTagAttribute = {}));
var PRPLDirectionAttributeValue;
(function (PRPLDirectionAttributeValue) {
    PRPLDirectionAttributeValue["asc"] = "asc";
    PRPLDirectionAttributeValue["desc"] = "desc";
})(PRPLDirectionAttributeValue || (PRPLDirectionAttributeValue = {}));
var PRPLRequiredMetadata;
(function (PRPLRequiredMetadata) {
    PRPLRequiredMetadata["title"] = "title";
    PRPLRequiredMetadata["slug"] = "slug";
})(PRPLRequiredMetadata || (PRPLRequiredMetadata = {}));
var PRPLFileSystemTreeEntity;
(function (PRPLFileSystemTreeEntity) {
    PRPLFileSystemTreeEntity["directory"] = "directory";
    PRPLFileSystemTreeEntity["file"] = "file";
})(PRPLFileSystemTreeEntity || (PRPLFileSystemTreeEntity = {}));
var PRPLCachePartitionKey;
(function (PRPLCachePartitionKey) {
    PRPLCachePartitionKey["src"] = "src";
    PRPLCachePartitionKey["content"] = "content";
    PRPLCachePartitionKey["dist"] = "dist";
})(PRPLCachePartitionKey || (PRPLCachePartitionKey = {}));

async function readDirSafe(dirPath) {
    let dirData = null;
    try {
        dirData = await readdir(dirPath);
    }
    catch (error) {
        if (error?.code == 'EACCES' || error?.code == 'EPERM') {
            return dirData;
        }
        else {
            throw error;
        }
    }
    return dirData;
}

async function generateFileSystemTree(args) {
    const { entityPath, readFileRegExp } = args;
    const name = basename(entityPath);
    const item = {
        path: entityPath,
        name,
        entity: null
    };
    let stats;
    try {
        stats = await stat(entityPath);
    }
    catch (_) {
        return null;
    }
    if (stats?.isFile()) {
        const { dir, base } = parse(entityPath);
        item.srcRelativeDir = dir?.replace(resolve('.'), '');
        item.srcRelativeFilePath = `${item?.srcRelativeDir.split(sep).slice(1).join(sep)}${sep}${base}`;
        item.targetFilePath = entityPath?.replace('src', 'dist');
        item.targetDir = parse(item?.targetFilePath)?.dir;
        item.extension = extname(entityPath)?.toLowerCase();
        item.entity = PRPLFileSystemTreeEntity.file;
        try {
            if (typeof readFileRegExp === 'object' && readFileRegExp?.constructor == RegExp) {
                if (readFileRegExp?.test(item?.extension)) {
                    const srcBuffer = await readFile(item?.path);
                    item.src = srcBuffer?.toString();
                }
            }
            return item;
        }
        catch (_) { }
    }
    if (stats?.isDirectory()) {
        let entitiesInDirectory = await readDirSafe(item?.path);
        if (entitiesInDirectory === null) {
            return null;
        }
        item.children = [];
        for (let i = 0; i < entitiesInDirectory?.length; i++) {
            const child = await generateFileSystemTree({
                entityPath: join(item?.path, entitiesInDirectory?.[i]),
                readFileRegExp
            });
            item?.children?.push(child);
        }
        item.entity = PRPLFileSystemTreeEntity.directory;
        return item;
    }
    return null;
}

const log = {
    debug(...args) {
        console.debug('\x1b[35m', '[PRPL]', ...args, '\x1b[0m');
    },
    info(...args) {
        console.info('\x1b[35m', '[PRPL]', ...args, '\x1b[0m');
    },
    warning(...args) {
        console.warn('\x1b[35m', '[PRPL]', ...args, '\x1b[0m');
    },
    error(...args) {
        console.error('\x1b[35m', '[PRPL]', ...args, '\x1b[0m');
    },
    critical(...args) {
        console.error('\x1b[35m', '[PRPL]', ...args, '\x1b[0m');
    }
};

const PRPLCache = {
    cache: {
        [PRPLCachePartitionKey.src]: {},
        [PRPLCachePartitionKey.content]: {},
        [PRPLCachePartitionKey.dist]: {}
    },
    async define(partitionKey) {
        try {
            PRPLCache.cache[partitionKey] = {};
        }
        catch (error) {
            log.error(`Failed to define a new partition '${partitionKey}'. Error:`, error?.message);
        }
    },
    async get(partitionKey, dirPath) {
        try {
            return PRPLCache?.cache?.[partitionKey]?.[dirPath];
        }
        catch (error) {
            log.error(`Failed to get cached item '${dirPath}' in partition '${partitionKey}'. Error:`, error?.message);
        }
    },
    async set(partitionKey, dirPath, item) {
        try {
            PRPLCache.cache[partitionKey][dirPath] = item;
        }
        catch (error) {
            log.error(`Failed to cache item '${dirPath}' in partition '${partitionKey}'. Error:`, error?.message);
        }
    }
};

async function generateOrRetrieveFileSystemTree(args) {
    const { partitionKey, entityPath, readFileRegExp } = args;
    try {
        let fileSystemTree = await PRPLCache?.get(partitionKey, entityPath);
        if (!fileSystemTree) {
            fileSystemTree = await generateFileSystemTree({
                entityPath,
                readFileRegExp
            });
            await PRPLCache?.set(partitionKey, entityPath, fileSystemTree);
        }
        return fileSystemTree;
    }
    catch (error) {
        log.error(`Failed generate file system tree from '${entityPath}'. Error:`, error?.message);
    }
}

async function cwd(importMeta) {
    try {
        return parse(fileURLToPath(importMeta.url)).dir;
    }
    catch (error) {
        log.error('Failed to get current working directory. Error:', error?.message);
    }
}

async function ensureDir(dir) {
    try {
        const fileInfo = await stat(dir);
        if (!fileInfo.isDirectory()) {
            log.error(`There is no directory at path '${dir}'.`);
        }
    }
    catch (error) {
        if (error?.code === 'ENOENT') {
            await mkdir(dir, { recursive: true });
            return;
        }
        log.error(`Failed to ensure '${dir}' exists. Error:`, error?.message);
    }
}

async function parsePRPLAttributes(args) {
    const { html } = args || {};
    return [...html?.matchAll(/<prpl(.*?)>/gs)]
        .map((attrs) => attrs?.[1]?.trim())
        .reduce((attrsCollection, attrs) => {
        attrsCollection?.push({
            raw: attrs,
            parsed: [...attrs?.matchAll(/\s*((.*?)="(.*?)")/g)]?.reduce((acc, curr) => {
                return {
                    ...acc,
                    [curr?.[2]]: curr?.[3]
                };
            }, {})
        });
        return attrsCollection;
    }, []);
}

async function parsePRPLMetadata(args) {
    const { src, srcRelativeFilePath } = args || {};
    let metadata;
    let body;
    try {
        const metadataStringRegex = new RegExp(`${EOL}$`, 's');
        const metadataString = /<!--(.*?)-->/s?.exec(src)?.[1]?.replace(metadataStringRegex, '');
        const metadataArrayRegex = new RegExp(`${EOL}(.*?): `, 'm');
        const metadataArray = metadataString?.split(metadataArrayRegex)?.slice(1);
        metadata = metadataArray?.reduce((acc, curr, index) => {
            if (!(index % 2)) {
                acc[curr] = metadataArray?.[index + 1];
            }
            return acc;
        }, {});
        const metadataBodyRegex = new RegExp(`-->${EOL}(.*?)$`, 's');
        body = metadataBodyRegex.exec(src)?.[1];
    }
    catch (error) {
        console.error(`Unable to parse metadata${srcRelativeFilePath ? ` in page ${srcRelativeFilePath}` : ''}. Metadata must be at the top of your file with at least a title and slug property:
    <!--
    title: Hello world!
    slug: hello-world
    -->`);
    }
    return {
        ...metadata,
        body
    };
}

async function interpolateList(args) {
    const { srcTree, contentDir, attrs, options = {} } = args || {};
    const contentTreeReadFileRegExp = new RegExp(`${PRPLContentFileExtension.html}|${PRPLContentFileExtension.markdown}`);
    const contentTree = await generateOrRetrieveFileSystemTree({
        partitionKey: PRPLCachePartitionKey.content,
        entityPath: contentDir,
        readFileRegExp: contentTreeReadFileRegExp
    });
    const contentFiles = contentTree?.children || [];
    const listRegex = new RegExp(`(<prpl\\s+${attrs?.raw}\\s?>)(.*?)<\/prpl>`, 's');
    const PRPLListTemplate = srcTree?.src?.match(listRegex)?.[2];
    let fragmentList = [];
    listLoop: for (let i = 0; i < contentFiles?.length; i++) {
        if (contentFiles?.[i]?.entity === PRPLFileSystemTreeEntity.directory) {
            continue listLoop;
        }
        let metadata;
        switch (contentFiles?.[i]?.extension) {
            case PRPLContentFileExtension.html:
            case PRPLContentFileExtension.markdown:
                metadata = await parsePRPLMetadata({
                    src: contentFiles?.[i]?.src,
                    srcRelativeFilePath: contentFiles?.[i]?.srcRelativeFilePath
                });
                break;
            default:
                log.error(`Unsupported content file extension '${contentFiles?.[i]?.extension}' from '${contentFiles?.[i]?.srcRelativeFilePath}'. Supported content file extensions include: '.html' and '.md'.`);
                fragmentList?.push({
                    metadata: {},
                    fragment: ''
                });
                continue;
        }
        let prplTemplateInstance = String(PRPLListTemplate);
        for (const key in metadata) {
            const regex = typeof options?.templateRegex === 'function'
                ? options?.templateRegex(key)
                : new RegExp(`\\[${key}\\]`, 'g');
            prplTemplateInstance = prplTemplateInstance?.replace(regex, metadata?.[key]);
        }
        fragmentList?.push({
            metadata,
            fragment: prplTemplateInstance
        });
    }
    if (PRPLTagAttribute.sortBy in attrs?.parsed) {
        const sort = attrs?.parsed?.[PRPLTagAttribute.sortBy];
        let direction = attrs?.parsed?.[PRPLTagAttribute.direction] || PRPLDirectionAttributeValue.asc;
        try {
            fragmentList = fragmentList?.sort((first, second) => {
                let firstComparator = first?.metadata?.[sort];
                let secondComparator = second?.metadata?.[sort];
                if (sort?.toLowerCase() === 'date' || sort?.toLowerCase() === 'time') {
                    firstComparator = new Date(firstComparator)?.getTime();
                    secondComparator = new Date(secondComparator)?.getTime();
                    return direction === PRPLDirectionAttributeValue.asc
                        ? firstComparator - secondComparator
                        : secondComparator - firstComparator;
                }
                if (firstComparator === secondComparator) {
                    return 0;
                }
                return direction === PRPLDirectionAttributeValue.asc
                    ? firstComparator > secondComparator
                        ? 1
                        : -1
                    : secondComparator < firstComparator
                        ? -1
                        : 1;
            });
        }
        catch (error) {
            log.error(`Failed to sort by '${sort}' in ${srcTree?.srcRelativeFilePath}. Error:`, error?.message);
        }
    }
    if (PRPLTagAttribute.limit in attrs?.parsed) {
        const limit = Number(attrs?.parsed?.[PRPLTagAttribute.limit]);
        try {
            fragmentList = fragmentList?.slice(0, limit);
        }
        catch (error) {
            log.error(`Failed to limit to '${limit}' in ${srcTree?.srcRelativeFilePath}. Error:`, error?.message);
        }
    }
    return fragmentList?.map((item) => item?.fragment).join('');
}

const renderer = {
    code(code, lang) {
        return `<pre class="language-${lang}"><code class="language-${lang}">${code}</code></pre>`;
    }
};
marked.use({ renderer });
async function transformMarkdown(args) {
    const { markdown, options = {} } = args || {};
    return marked(markdown, options?.markedOptions);
}

async function interpolatePage(args) {
    const { srcTree, contentDir, attrs = [], options = {} } = args || {};
    const contentTreeReadFileRegExp = new RegExp(`${PRPLContentFileExtension.html}|${PRPLContentFileExtension.markdown}`);
    const contentTree = await generateOrRetrieveFileSystemTree({
        partitionKey: PRPLCachePartitionKey.content,
        entityPath: contentDir,
        readFileRegExp: contentTreeReadFileRegExp
    });
    const contentFiles = contentTree?.children || [];
    const listAttrs = attrs?.slice(1);
    let listFragmentMap = {};
    for (let a = 0; a < listAttrs?.length; a++) {
        listFragmentMap[listAttrs?.[a]?.raw] = await interpolateList({
            srcTree,
            contentDir,
            attrs: listAttrs?.[a],
            options
        });
    }
    pageLoop: for (let p = 0; p < contentFiles?.length; p++) {
        if (contentFiles?.[p]?.entity === PRPLFileSystemTreeEntity.directory) {
            continue pageLoop;
        }
        const page = {
            ...srcTree,
            name: contentFiles?.[p]?.name,
            extension: contentFiles?.[p]?.extension,
            targetFilePath: srcTree?.targetFilePath?.replace(srcTree?.name, contentFiles?.[p]?.name)
        };
        let metadata;
        switch (page?.extension) {
            case PRPLContentFileExtension.html:
                metadata = await parsePRPLMetadata({
                    src: contentFiles?.[p]?.src,
                    srcRelativeFilePath: contentFiles?.[p]?.srcRelativeFilePath
                });
                break;
            case PRPLContentFileExtension.markdown:
                page.targetFilePath = page.targetFilePath?.replace(page?.extension, PRPLSourceFileExtension.html);
                page.extension = PRPLSourceFileExtension.html;
                metadata = await parsePRPLMetadata({
                    src: contentFiles?.[p]?.src,
                    srcRelativeFilePath: contentFiles?.[p]?.srcRelativeFilePath
                });
                metadata.body = await transformMarkdown({
                    markdown: metadata?.body,
                    options
                });
                break;
            default:
                log.error(`File '${contentFiles?.[p]?.srcRelativeFilePath}' has unsupported extension '${contentFiles?.[p]?.extension}'. Supported extensions include '.html' and '.md'.`);
                continue pageLoop;
        }
        for (const rawListAttrs in listFragmentMap) {
            const listRegex = new RegExp(`<prpl\\s+${rawListAttrs}\\s?>.*?<\/prpl>`, 's');
            page.src = page?.src?.replace(listRegex, listFragmentMap?.[rawListAttrs]);
        }
        let pageFragmentInstance = page?.src?.match(/(<prpl.*?>)(.*?)<\/prpl>/s)?.[2];
        for (const key in metadata) {
            const metadataKeyRegex = typeof options?.templateRegex === 'function'
                ? options?.templateRegex(key)
                : new RegExp(`\\[${key}\\]`, 'g');
            pageFragmentInstance = pageFragmentInstance?.replace(metadataKeyRegex, metadata?.[key]);
        }
        const interpolatedPage = page?.src.replace(/<prpl.*<\/prpl>/s, pageFragmentInstance);
        await writeFile(page?.targetFilePath, interpolatedPage);
    }
}

async function interpolateHTML(args) {
    const { srcTree, options = {} } = args || {};
    if (!options?.noClientJS) {
        srcTree.src = srcTree?.src?.replace(/<\/head>/, `<script type="module" src="prefetch.js"></script>${EOL}<script type="module" src="router.js"></script>${EOL}</head>`);
    }
    if (!/<prpl/?.test(srcTree?.src)) {
        await writeFile(srcTree?.targetFilePath, srcTree?.src);
        return;
    }
    const attrs = await parsePRPLAttributes({ html: srcTree?.src });
    const firstAttr = attrs?.[0];
    const firstPRPLAttrIsPage = firstAttr?.parsed?.[PRPLTagAttribute?.type] === PRPLTag.page;
    if (firstAttr && !firstPRPLAttrIsPage) {
        const page = { ...srcTree };
        for (let a = 0; a < attrs?.length; a++) {
            const contentDir = resolve(attrs?.[a]?.parsed?.[PRPLTagAttribute?.src]);
            const listFragment = await interpolateList({
                srcTree,
                contentDir,
                attrs: attrs?.[a],
                options
            });
            const listRegex = new RegExp(`<prpl\\s+${attrs?.[a]?.raw}\\s?>.*<\/prpl>`, 's');
            page.src = page?.src?.replace(listRegex, listFragment);
        }
        await writeFile(page?.targetFilePath, page?.src);
        return;
    }
    const contentDir = resolve(firstAttr?.parsed?.[PRPLTagAttribute?.src]);
    await interpolatePage({
        srcTree,
        contentDir,
        attrs,
        options
    });
}

const PRPLClientScripts = [
    "prefetch",
    "prefetch-worker",
    "router"
];
async function interpolate(args) {
    const { options = {} } = args || {};
    await ensureDir(resolve('dist'));
    if (!options?.noClientJS) {
        for (let s = 0; s < PRPLClientScripts.length; s++) {
            try {
                await copyFile(resolve(await cwd(import.meta), 'client', `${PRPLClientScripts[s]}.js`), resolve(`dist`, `${PRPLClientScripts[s]}.js`));
            }
            catch (error) {
                log.error(`Failed to copy '${PRPLClientScripts[s]}.js' to dist. Error:`, error?.message);
            }
        }
    }
    async function walkSourceTree(items) {
        for (let i = 0; i < items.length; i++) {
            switch (items?.[i]?.entity) {
                case 'file':
                    await ensureDir(items?.[i]?.targetDir);
                    if (items?.[i]?.extension === PRPLSourceFileExtension.html) {
                        await interpolateHTML({ srcTree: items?.[i], options });
                        break;
                    }
                    try {
                        await copyFile(items?.[i]?.path, items?.[i]?.targetFilePath);
                    }
                    catch (error) {
                        log.error(`Failed to copy '${items?.[i]?.srcRelativeFilePath}' to dist. Error:`, error?.message);
                    }
                    break;
                case 'directory':
                    await walkSourceTree(items?.[i]?.children);
                    break;
            }
        }
    }
    const srcDir = resolve('src');
    const srcTreeReadFileRegExp = new RegExp(PRPLSourceFileExtension.html);
    const srcTree = await generateOrRetrieveFileSystemTree({
        partitionKey: PRPLCachePartitionKey.src,
        entityPath: srcDir,
        readFileRegExp: srcTreeReadFileRegExp
    });
    await walkSourceTree(srcTree?.children || []);
    log.info('Build complete');
    return PRPLCache?.cache;
}

async function ensureFile(filePath) {
    try {
        const stats = await stat(filePath);
        if (!stats.isFile()) {
            log.error(`There is no file at path '${filePath}'.`);
        }
    }
    catch (error) {
        if (error?.code === 'ENOENT') {
            await ensureDir(dirname(filePath));
            await writeFile(filePath, new Uint8Array());
            return;
        }
        log.error(`Failed to ensure '${filePath}' exists. Error:`, error?.message);
    }
}

async function exists(filePath) {
    try {
        await stat(filePath);
        return true;
    }
    catch (error) {
        if (error?.code === 'ENOENT') {
            return false;
        }
        log.error(`Failed to check '${filePath}' exists. Error:`, error?.message);
    }
}

export { PRPLCache, PRPLCachePartitionKey, PRPLContentFileExtension, PRPLDirectionAttributeValue, PRPLFileSystemTreeEntity, PRPLRequiredMetadata, PRPLSourceFileExtension, PRPLTag, PRPLTagAttribute, cwd, ensureDir, ensureFile, exists, generateFileSystemTree, generateOrRetrieveFileSystemTree, interpolate, interpolateHTML, interpolateList, interpolatePage, log, parsePRPLAttributes, parsePRPLMetadata, readDirSafe, transformMarkdown };
