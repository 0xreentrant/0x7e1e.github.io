import { resolve } from 'path';
import { readFile, writeFile, copyFile, rm } from 'fs/promises';
import http from 'http';
import handler from 'serve-handler';
import WebSocket from 'faye-websocket';
import chokidar from 'chokidar';
import open from 'open';
import { log, exists, cwd, generateFileSystemTree, PRPLSourceFileExtension, ensureDir, interpolateHTML } from '@prpl/core';

let ws;
let socketInjectedPages = [];
async function server() {
    const server = http.createServer();
    server.on('connection', async () => {
        await injectSocketOptionally('./dist/index.html');
    });
    server.on('request', async (request, response) => {
        if (request?.headers?.accept?.includes('text/html')) {
            const url = request?.url === '/' ? './dist/index.html' : `./dist${request.url}.html`;
            await injectSocketOptionally(url);
        }
        const config = {
            public: 'dist',
            cleanUrls: true,
            trailingSlash: false
        };
        return handler(request, response, config);
    });
    server.on('upgrade', async (request, socket, head) => {
        ws = new WebSocket(request, socket, head);
    });
    server.listen(8000);
    const watcher = chokidar?.watch(resolve('./src'), {
        ignoreInitial: true
    });
    watcher
        .on('change', async (changedFilePath) => {
        await createOrUpdateFile(changedFilePath, 'change');
    })
        .on('add', async (changedFilePath) => {
        await createOrUpdateFile(changedFilePath, 'add');
    })
        .on('unlink', async (changedFilePath) => {
        await removeFile(changedFilePath);
    });
    process.on('SIGINT', async () => {
        for (let i = 0; i < socketInjectedPages?.length; i++) {
            const pageBuffer = await readFile(resolve(socketInjectedPages?.[i]));
            const injectedPage = pageBuffer?.toString();
            const restoredPage = injectedPage?.replace(/<script dev>.*<\/script>/s, '');
            await writeFile(socketInjectedPages?.[i], restoredPage);
        }
        socketInjectedPages = [];
        process.exit(0);
    });
    await open('http://localhost:8000');
    log.info('Server listening at http://localhost:8000');
}
async function injectSocketOptionally(filePath) {
    const socketExists = await exists(filePath);
    if (!socketExists) {
        return;
    }
    const pageBuffer = await readFile(resolve(filePath));
    let page = pageBuffer?.toString();
    if (page?.includes('<script dev>')) {
        return;
    }
    const socketBuffer = await readFile(resolve(await cwd(import.meta), 'socket.js'));
    const socket = socketBuffer?.toString();
    page = page?.replace(/<\/head>/, `<script dev>
      ${socket}
    </script>
  </head>`);
    socketInjectedPages?.push(filePath);
    await writeFile(resolve(filePath), page);
}
async function createOrUpdateFile(changedFilePath, event) {
    const item = await generateFileSystemTree({
        entityPath: changedFilePath,
        readFileRegExp: new RegExp(PRPLSourceFileExtension.html)
    });
    await ensureDir(item?.targetDir);
    try {
        if (item?.extension === PRPLSourceFileExtension.html) {
            await interpolateHTML({ srcTree: item });
        }
        else {
            await copyFile(item?.path, item?.targetFilePath);
        }
        ws?.send(item?.srcRelativeFilePath === '/index.html' ? '/' : item?.srcRelativeFilePath);
        log.info(`${event === 'change' ? 'Updated' : 'Created'} ${item?.srcRelativeFilePath}`);
    }
    catch (error) {
        log.error(`Server failed to ${event === 'change' ? 'update' : 'create'} '${item?.srcRelativeFilePath}'. Error:`, error?.message);
    }
}
async function removeFile(removedFilePath) {
    const item = await generateFileSystemTree({
        entityPath: removedFilePath
    });
    try {
        if (item?.targetFilePath && (await exists(item?.targetFilePath))) {
            await rm(item?.targetFilePath);
            log.info(`Removed ${item?.srcRelativeFilePath}`);
        }
    }
    catch (error) {
        log.error(`Server failed to remove ${item?.srcRelativeFilePath}`);
    }
}

export { server };
