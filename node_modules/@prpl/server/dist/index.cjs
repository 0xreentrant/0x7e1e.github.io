'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var promises = require('fs/promises');
var http = require('http');
var handler = require('serve-handler');
var WebSocket = require('faye-websocket');
var chokidar = require('chokidar');
var open = require('open');
var core = require('@prpl/core');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
var handler__default = /*#__PURE__*/_interopDefaultLegacy(handler);
var WebSocket__default = /*#__PURE__*/_interopDefaultLegacy(WebSocket);
var chokidar__default = /*#__PURE__*/_interopDefaultLegacy(chokidar);
var open__default = /*#__PURE__*/_interopDefaultLegacy(open);

let ws;
let socketInjectedPages = [];
async function server() {
    const server = http__default['default'].createServer();
    server.on('connection', async () => {
        await injectSocketOptionally('./dist/index.html');
    });
    server.on('request', async (request, response) => {
        if (request?.headers?.accept?.includes('text/html')) {
            const url = request?.url === '/' ? './dist/index.html' : `./dist${request.url}.html`;
            await injectSocketOptionally(url);
        }
        const config = {
            public: 'dist',
            cleanUrls: true,
            trailingSlash: false
        };
        return handler__default['default'](request, response, config);
    });
    server.on('upgrade', async (request, socket, head) => {
        ws = new WebSocket__default['default'](request, socket, head);
    });
    server.listen(8000);
    const watcher = chokidar__default['default']?.watch(path.resolve('./src'), {
        ignoreInitial: true
    });
    watcher
        .on('change', async (changedFilePath) => {
        await createOrUpdateFile(changedFilePath, 'change');
    })
        .on('add', async (changedFilePath) => {
        await createOrUpdateFile(changedFilePath, 'add');
    })
        .on('unlink', async (changedFilePath) => {
        await removeFile(changedFilePath);
    });
    process.on('SIGINT', async () => {
        for (let i = 0; i < socketInjectedPages?.length; i++) {
            const pageBuffer = await promises.readFile(path.resolve(socketInjectedPages?.[i]));
            const injectedPage = pageBuffer?.toString();
            const restoredPage = injectedPage?.replace(/<script dev>.*<\/script>/s, '');
            await promises.writeFile(socketInjectedPages?.[i], restoredPage);
        }
        socketInjectedPages = [];
        process.exit(0);
    });
    await open__default['default']('http://localhost:8000');
    core.log.info('Server listening at http://localhost:8000');
}
async function injectSocketOptionally(filePath) {
    const socketExists = await core.exists(filePath);
    if (!socketExists) {
        return;
    }
    const pageBuffer = await promises.readFile(path.resolve(filePath));
    let page = pageBuffer?.toString();
    if (page?.includes('<script dev>')) {
        return;
    }
    const socketBuffer = await promises.readFile(path.resolve(await core.cwd(({ url: (typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)) })), 'socket.js'));
    const socket = socketBuffer?.toString();
    page = page?.replace(/<\/head>/, `<script dev>
      ${socket}
    </script>
  </head>`);
    socketInjectedPages?.push(filePath);
    await promises.writeFile(path.resolve(filePath), page);
}
async function createOrUpdateFile(changedFilePath, event) {
    const item = await core.generateFileSystemTree({
        entityPath: changedFilePath,
        readFileRegExp: new RegExp(core.PRPLSourceFileExtension.html)
    });
    await core.ensureDir(item?.targetDir);
    try {
        if (item?.extension === core.PRPLSourceFileExtension.html) {
            await core.interpolateHTML({ srcTree: item });
        }
        else {
            await promises.copyFile(item?.path, item?.targetFilePath);
        }
        ws?.send(item?.srcRelativeFilePath === '/index.html' ? '/' : item?.srcRelativeFilePath);
        core.log.info(`${event === 'change' ? 'Updated' : 'Created'} ${item?.srcRelativeFilePath}`);
    }
    catch (error) {
        core.log.error(`Server failed to ${event === 'change' ? 'update' : 'create'} '${item?.srcRelativeFilePath}'. Error:`, error?.message);
    }
}
async function removeFile(removedFilePath) {
    const item = await core.generateFileSystemTree({
        entityPath: removedFilePath
    });
    try {
        if (item?.targetFilePath && (await core.exists(item?.targetFilePath))) {
            await promises.rm(item?.targetFilePath);
            core.log.info(`Removed ${item?.srcRelativeFilePath}`);
        }
    }
    catch (error) {
        core.log.error(`Server failed to remove ${item?.srcRelativeFilePath}`);
    }
}

exports.server = server;
